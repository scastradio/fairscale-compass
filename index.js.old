// server.js
import express from "express";
import session from "express-session";
import dotenv from "dotenv";
import fetch from "node-fetch";
import { TwitterApi } from "twitter-api-v2";
import path from "path";

dotenv.config();

const {
  PORT = 3000,
  SESSION_SECRET = "devsecret",
  TWITTER_CLIENT_ID,
  TWITTER_CLIENT_SECRET,
  CALLBACK_URL,
  TWITTERAPI_IO_KEY,
  TWEET_COUNT = "50",
  INCLUDE_REPLIES = "false",
  WEBHOOK_URL,
} = process.env;

function required(name) {
  if (!process.env[name]) {
    console.error(`Missing required env var: ${name}`);
    process.exit(1);
  }
}
["TWITTER_CLIENT_ID", "TWITTER_CLIENT_SECRET", "CALLBACK_URL", "TWITTERAPI_IO_KEY", "WEBHOOK_URL"].forEach(required);

const app = express();
app.use("/assets", express.static(path.join(process.cwd(), "assets")));
app.use(session({ secret: SESSION_SECRET, resave: false, saveUninitialized: false }));

const oauthClient = new TwitterApi({ clientId: TWITTER_CLIENT_ID, clientSecret: TWITTER_CLIENT_SECRET });

app.get("/", (req, res) => {
  if (req.session?.accessToken) return res.redirect("/fetch");
  res.send(`<!doctype html><html><head><meta charset="utf-8"/>
  <title>Fairscale Compass</title><meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>:root{color-scheme:dark}*{box-sizing:border-box}
  @font-face{font-family:Manrope;src:url('/assets/fonts/Manrope-Bold.ttf') format('truetype');font-weight:700;font-display:swap}
  body{margin:0;background:#000;color:#fff;font-family:Manrope,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{min-height:100vh;display:grid;place-items:center;padding:24px}.container{max-width:960px;text-align:center}
  .logo{height:76px;width:auto;margin-bottom:16px}.title{font-weight:800;font-size:46px;color:#f4c217;margin:10px 0 16px}
  .desc{color:#c9c9c9;font-size:19px;line-height:1.7;margin:0 auto 28px;max-width:820px}
  .cta{display:inline-flex;align-items:center;gap:10px;background:#f4c217;color:#000;font-weight:800;font-size:18px;padding:14px 22px;border-radius:999px;border:0;cursor:pointer;box-shadow:0 10px 30px rgba(244,194,23,.25);text-decoration:none}
  .cta:hover{background:#ffd54a}.cta .x{font-size:22px;line-height:1}.fine{margin-top:22px;color:#9a9a9a;font-size:12px}
  @media(max-width:640px){.logo{height:60px}.title{font-size:34px}.desc{font-size:17px}}</style></head>
  <body><main class="wrap"><section class="container">
  <img class="logo" src="/assets/logo.png" alt="Fairscale Logo"/>
  <h1 class="title">Fairscale Compass</h1>
  <p class="desc">Connect your X account and we‚Äôll generate a sleek sentiment gauge from your recent posts. We‚Äôll fetch your handle and render a preview with the needle positioned by your latest activity ‚Äî perfect for demos, teasers, and social sharing.</p>
  <a class="cta" href="/login"><span class="x">ùïè</span> Connect with X</a>
  <p class="fine">By continuing you agree to simulate non-production scores.</p>
  </section></main></body></html>`);
});

app.get("/login", async (req, res) => {
  const { url, codeVerifier, state } = oauthClient.generateOAuth2AuthLink(CALLBACK_URL, {
    scope: ["tweet.read", "users.read", "offline.access"],
  });
  req.session.state = state;
  req.session.codeVerifier = codeVerifier;
  res.redirect(url);
});

app.get("/callback", async (req, res) => {
  const { state, code } = req.query;
  if (!state || !code || state !== req.session.state) return res.status(400).send("Invalid OAuth2 callback");
  try {
    const { client, accessToken } = await oauthClient.loginWithOAuth2({
      code,
      codeVerifier: req.session.codeVerifier,
      redirectUri: CALLBACK_URL,
    });
    req.session.accessToken = accessToken;
    const me = await client.v2.me();
    req.session.userId = me.data.id;
    req.session.username = me.data.username;
    res.redirect("/fetch");
  } catch (e) {
    console.error("OAuth2 callback error:", e);
    res.status(500).send("Callback failed");
  }
});

app.get("/fetch", async (req, res) => {
  if (!req.session?.accessToken || (!req.session?.userId && !req.session?.username)) return res.redirect("/login");

  const desired = Math.max(1, Number(TWEET_COUNT) || 50);
  const includeReplies = String(INCLUDE_REPLIES).toLowerCase() === "true";

  try {
    const collected = [];
    let cursor = "";
    while (collected.length < desired) {
      const url = new URL("https://api.twitterapi.io/twitter/user/last_tweets");
      if (req.session.userId) url.searchParams.set("userId", req.session.userId);
      else if (req.session.username) url.searchParams.set("userName", req.session.username);
      url.searchParams.set("includeReplies", includeReplies ? "true" : "false");
      if (cursor) url.searchParams.set("cursor", cursor);

      const resp = await fetch(url.toString(), { method: "GET", headers: { "x-api-key": TWITTERAPI_IO_KEY, accept: "application/json" } });
      if (!resp.ok) throw new Error(`TwitterAPI.io error ${resp.status}: ${await resp.text().catch(() => "")}`);

      const data = await resp.json();
      const page = Array.isArray(data.data?.tweets) ? data.data.tweets : [];
      if (page.length === 0) break;
      collected.push(...page);
      if (!data.has_next_page || !data.next_cursor) break;
      cursor = data.next_cursor;
    }

    const tweetsToSend = collected.slice(0, desired);

    const webhookResp = await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        user: { id: req.session.userId, username: req.session.username },
        count: tweetsToSend.length,
        tweets: tweetsToSend,
        source: "twitterapi.io",
      }),
    });

    const bodyText = await webhookResp.text();

    let displayScore = null;
    try {
      const parsedAny = JSON.parse(bodyText);
      let P = 0, Neut = 0, Neg = 0;
      if (Array.isArray(parsedAny)) {
        for (const obj of parsedAny) {
          if (obj && typeof obj === "object") {
            if (typeof obj.Positive === "number") P += obj.Positive;
            if (typeof obj.Neutral === "number") Neut += obj.Neutral;
            if (typeof obj.Negative === "number") Neg += obj.Negative;
          }
        }
      } else if (typeof parsedAny === "object") {
        if (typeof parsedAny.Positive === "number") P = parsedAny.Positive;
        if (typeof parsedAny.Neutral === "number") Neut = parsedAny.Neutral;
        if (typeof parsedAny.Negative === "number") Neg = parsedAny.Negative;
      }
      const T = P + Neut + Neg || tweetsToSend.length || 0;
      if (T > 0) displayScore = Math.round(((P - Neg + T) / (2 * T)) * 100);
    } catch {
      console.log(`Webhook response (raw): ${bodyText}`);
    }

    if (displayScore !== null) {
      return res.send(`<!doctype html>
<html><head><meta charset="utf-8"/><title>Fairscale Compass ‚Äî Gauge</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>:root{color-scheme:dark}
body{background:#0f0f10;color:#e8e8e8;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px}
.wrap{max-width:760px;margin:0 auto;text-align:center}
#gauge{width:720px;height:420px;max-width:100%;display:block;margin:0 auto}
.btns{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
button,a.btn{font-size:15px;padding:10px 16px;border:1px solid #2a2a2a;border-radius:10px;background:#1a1a1b;color:#e8e8e8;cursor:pointer;text-decoration:none}
button:hover,a.btn:hover{background:#222}</style></head>
<body><div class="wrap"><canvas id="gauge" width="720" height="420"></canvas>
<div class="btns" style="margin-top:18px;"><button id="downloadPng">Download</button><a class="btn" href="/logout">Logout</a></div></div>
<script>(function(){
  const value = Math.max(0, Math.min(100, ${displayScore}));

  const C_RED = 'rgb(217,83,79)';
  const C_ORG = 'rgb(240,173,78)';
  const C_GRN = 'rgb(92,184,92)';

  const canvas = document.getElementById('gauge');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;

  const cx = w/2;
  const radius = Math.min(w,h)*0.42;
  const cy = h*0.74;
  const start = Math.PI;
  const end = 2*Math.PI;
  const trackW = 22;
  const valueW = 16;
  const PAD = 18;

  function drawTrack(){
    ctx.save();
    ctx.lineCap='round';
    ctx.lineWidth=trackW;
    ctx.strokeStyle='#3a3a3d';
    ctx.beginPath();
    ctx.arc(cx,cy,radius,start,end,false);
    ctx.stroke();
    ctx.restore();
  }

  // --- FIX: red cap segment + gradient starting after the cap ---
  function drawValue(v){
    const thetaEnd = start + (v/100)*(end-start);
    const capAngle = (valueW/2) / radius; // radians the round cap covers

    // 1) If the needle is very small, paint it all red and return
    if (thetaEnd <= start + capAngle) {
      ctx.save();
      ctx.lineCap='round';
      ctx.lineWidth=valueW;
      ctx.strokeStyle=C_RED;
      ctx.beginPath();
      ctx.arc(cx,cy,radius,start,thetaEnd,false);
      ctx.stroke();
      ctx.restore();
      return;
    }

    // 2) Paint a tiny solid-red segment to cover the start cap
    ctx.save();
    ctx.lineCap='round';
    ctx.lineWidth=valueW;
    ctx.strokeStyle=C_RED;
    ctx.beginPath();
    ctx.arc(cx,cy,radius,start,start+capAngle,false);
    ctx.stroke();
    ctx.restore();

    // 3) Smooth gradient for the rest, seam pinned away from the start
    const gradStart = start + capAngle + 1e-4; // tiny epsilon to avoid AA bleed
    const grad = ctx.createConicGradient(gradStart, cx, cy);
    grad.addColorStop(0.00,  C_RED);
    grad.addColorStop(0.50,  C_ORG);
    grad.addColorStop(1.00,  C_GRN);

    ctx.save();
    ctx.lineCap='butt';           // no extra round cap where gradient begins
    ctx.lineWidth=valueW;
    ctx.strokeStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,radius,start+capAngle,thetaEnd,false);
    ctx.stroke();
    ctx.restore();
  }

  function drawTicksAndLabels(){
    const labels=[["Strongly","Bearish"],["Bearish"],["Neutral"],["Bullish"],["Strongly","Bullish"]];
    const steps=labels.length-1;

    ctx.save();
    ctx.fillStyle='#bfbfc4';
    ctx.strokeStyle='#777';
    ctx.lineWidth=2;
    ctx.font='16px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif';

    const inset=(end-start)*0.02;

    for(let i=0;i<=steps;i++){
      let a=start+(i/steps)*(end-start);
      if(i===0)a=start+inset;
      if(i===steps)a=end-inset;

      const x1=cx+Math.cos(a)*(radius+6);
      const y1=cy+Math.sin(a)*(radius+6);
      const x2=cx+Math.cos(a)*(radius+22);
      const y2=cy+Math.sin(a)*(radius+22);
      ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();

      let lx,ly,rLabel,align;
      if(i===0||i===steps){
        rLabel=radius+84; lx=cx+Math.cos(a)*rLabel; ly=cy+Math.sin(a)*rLabel+14;
        if(i===0){align='left'; lx=Math.max(PAD,lx);} else {align='right'; lx=Math.min(w-PAD,lx);}
      }else{
        rLabel=radius+46; lx=cx+Math.cos(a)*rLabel; ly=cy+Math.sin(a)*rLabel-4; align='center';
      }
      ctx.textAlign=align;
      const lines=labels[i];
      if(lines.length===2){ctx.fillText(lines[0],lx,ly-10);ctx.fillText(lines[1],lx,ly+10);}
      else{ctx.fillText(lines[0],lx,ly);}
    }
    ctx.restore();
  }

  function drawNeedle(v){
    const a=start+(v/100)*(end-start);
    const r1=radius-66, r2=radius+10;
    const x1=cx+Math.cos(a)*r1, y1=cy+Math.sin(a)*r1;
    const x2=cx+Math.cos(a)*r2, y2=cy+Math.sin(a)*r2;
    ctx.save();ctx.strokeStyle='#e6e6e8';ctx.lineWidth=4;ctx.lineCap='round';
    ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();ctx.restore();
  }

  const logo=new Image(); logo.src='/assets/fs.png'; let logoReady=false; logo.onload=()=>{logoReady=true; render(value);};
  function drawLogo(){
    if(!logoReady)return;
    const maxW=radius*1.15, maxH=radius*0.28;
    const ratio=Math.min(maxW/logo.width, maxH/logo.height);
    const wDraw=Math.max(1,Math.floor(logo.width*ratio));
    const hDraw=Math.max(1,Math.floor(logo.height*ratio));
    const x=cx-wDraw/2; const y=cy-hDraw/2 - radius*0.22;
    ctx.drawImage(logo,x,y,wDraw,hDraw);
  }

  function render(v){
    ctx.clearRect(0,0,w,h);
    drawTrack();
    drawValue(v);
    drawTicksAndLabels();
    drawNeedle(v);
    drawLogo();
  }

  render(value);

  document.getElementById('downloadPng').addEventListener('click',()=>{
    const url=canvas.toDataURL('image/png');
    const a=document.createElement('a'); a.href=url; a.download='sentiment-gauge-'+Date.now()+'.png';
    document.body.appendChild(a); a.click(); a.remove();
  });

  console.log('Gauge rendered',{value});
})();</script></body></html>`);
    }

    res.send(`<p style="font-family:system-ui;color:#eee;">Sent ${tweetsToSend.length} tweets from @${req.session.username} to webhook.</p>
    <pre style="white-space:pre-wrap;color:#ccc;background:#111;padding:12px;border-radius:8px;">Webhook response: ${bodyText}</pre>
    <p><a href="/" style="color:#9cf;">Back</a></p>`);
  } catch (e) {
    console.error("Error fetching/sending tweets:", e);
    res.status(500).send("Failed to fetch tweets or send to webhook.");
  }
});

app.get("/logout", (req, res) => req.session.destroy(() => res.redirect("/")));

app.listen(Number(PORT), () => {
  console.log(`Server running: http://localhost:${Number(PORT)}`);
});
